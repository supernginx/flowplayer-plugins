/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi, <electroteque@gmail.com>, Anssi Piirainen Flowplayer Oy * Copyright (c) 2009 Electroteque Multimedia, Flowplayer Oy * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.bwcheck {    import de.betriebsraum.video.BufferCalculator;    import flash.display.DisplayObject;    import flash.display.Sprite;    import flash.events.NetStatusEvent;    import flash.net.NetConnection;    import flash.net.NetStream;    import flash.net.NetStreamPlayOptions;    import flash.net.NetStreamPlayTransitions;    import flash.utils.Timer;    import org.flowplayer.bwcheck.detect.BandwidthDetector;    import org.flowplayer.bwcheck.detect.DynamicStreamEvent;    import org.flowplayer.bwcheck.model.BitrateItem;    import org.flowplayer.bwcheck.strategy.ScreenSizeRule;    import org.flowplayer.bwcheck.strategy.StreamSelectionFactory;    import org.flowplayer.bwcheck.strategy.StreamSelectionRule;    import org.flowplayer.cluster.RTMPCluster;    import org.flowplayer.controller.ClipURLResolver;    import org.flowplayer.controller.NetStreamClient;    import org.flowplayer.controller.StreamProvider;    import org.flowplayer.model.Clip;    import org.flowplayer.model.ClipEvent;    import org.flowplayer.model.ClipType;    import org.flowplayer.model.PlayerEvent;    import org.flowplayer.model.Plugin;    import org.flowplayer.model.PluginEventType;    import org.flowplayer.model.PluginModel;    import org.flowplayer.ui.AutoHide;    import org.flowplayer.util.PropertyBinder;    import org.flowplayer.view.AbstractSprite;    import org.flowplayer.view.Flowplayer;    import org.osmf.logging.Log;    import org.osmf.net.DynamicStreamingItem;    import org.osmf.net.DynamicStreamingResource;    import org.osmf.net.NetClient;    import org.osmf.net.NetStreamSwitchManager;    import org.osmf.net.SwitchingRuleBase;    import org.osmf.net.rtmpstreaming.*;    import org.flowplayer.bwcheck.detect.BandwidthDetectEvent;    /**     * @author danielr     */    public class BitrateProvider extends AbstractSprite  implements ClipURLResolver, Plugin {        private var _config:Config;        //private var log:Log = new Log(this);        private var _netStream:NetStream;        private var _resolveSuccessListener:Function;        private var _failureListener:Function;        private var _clip:Clip;        private var _hasDetectedBW:Boolean = false;        protected var _infoTimer:Timer;        private var _start:Number = 0;        private var _model:PluginModel;        protected var _previousStreamName:String;        private var _player:Flowplayer;        private var _resolving:Boolean;        private var _currentBitrateItem:BitrateItem;        private var _initFailed:Boolean;        private var _playButton:DisplayObject;        private var _provider:StreamProvider;        private var _dynamicStreamName:String;        private var _dynamicOldStreamName:String;        private var _dynamicBitrateItem:BitrateItem;        private var _bitrateStorage:BitrateStorage;        private var _streamSelection:StreamSelectionFactory;        private var _detector:BandwidthDetector;        private var _iconBar:IconBar;        private var _panelContainer:Sprite;        private var _autoHide:AutoHide;        private var _hdIndex:Number;        private var _hasHD:Boolean;        /**         * OSMF features         */        private var _switchManager:NetStreamSwitchManager;        private var dsResource:DynamicStreamingResource;        public function onConfig(model:PluginModel):void {            log.debug("onConfig(_)");            Log.loggerFactory = new OsmfLoggerFactory();            _config = new PropertyBinder(new Config(), null).copyProperties(model.config) as Config;            _model = model;            _bitrateStorage = new BitrateStorage(_config.bitrateProfileName, "/");            _bitrateStorage.expiry = _config.cacheExpiry;            log.debug("onConfig(), dynamic " + _config.dynamic);        }        private function applyForClip(clip:Clip):Boolean {            log.debug("applyForClip(), clip.urlResolvers == " + clip.urlResolvers);            if (clip.urlResolvers == null) return false;            var apply:Boolean = clip.urlResolvers.indexOf(_model.name) >= 0;            log.debug("applyForClip? " + apply);            return apply;        }        public function onLoad(player:Flowplayer):void {            log.debug("onLoad()");            //if (_initFailed) return;            _player = player;            _detector = new BandwidthDetector(_model, _config);            _detector.addEventListener(BandwidthDetectEvent.DETECT_COMPLETE, onDetectorComplete);            _detector.addEventListener(BandwidthDetectEvent.CLUSTER_FAILED, onClusterFailed);            if (_config.streamSelectionFullScreen) {                _player.onFullscreen(onFullscreen);                _player.onFullscreenExit(onFullscreen);            }            _player.playlist.onBeforeBegin(function(event:ClipEvent):void {                var clip:Clip = event.target as Clip;                if (clip.getCustomProperty("bitrates") != null) buildBitrateList(clip);            }, applyForClip);            _player.playlist.onBegin(function(event:ClipEvent):void {                var clip:Clip = event.target as Clip;                init(clip.getNetStream(), clip);                if (_config.dynamic) {                    initQoS(clip.getNetStream(), clip);                }            }, function(clip:Clip):Boolean { return clip.type != ClipType.IMAGE && applyForClip(clip) });                        _player.playlist.onPause(function(event:ClipEvent):void {                if (! _switchManager) return;                _switchManager.autoSwitch = false;            });            _player.playlist.onResume(function(event:ClipEvent):void {                if (_config.dynamic) {                    _switchManager.autoSwitch = true;                }            });            _player.playlist.onFinish(function(event:ClipEvent):void {                if (! _switchManager) return;                _switchManager.autoSwitch = false;            });            _model.dispatchOnLoad();        }        private function onFullscreen(event:PlayerEvent):void {            if (_player.streamProvider.type == "http") {                log.debug("onFullscreen(), doing progressive download and will not detect again on fullscreen");                return;            }            if (! _config.dynamic) {                log.debug("onFullscreen(), detecting bandwidth");                checkBandwidthIfNotDetectedYet();            }        }        private function alreadyResolved(clip:Clip):Boolean {            return clip.getCustomProperty("bwcheckResolvedUrl") != null;        }        protected function hasDetectedBW():Boolean {            if (! _config.rememberBitrate) return false;            if (_hasDetectedBW) return true;            if (isRememberedBitrateValid()) return true;            return false;        }        public function set onFailure(listener:Function):void {            _failureListener = listener;        }        public function handeNetStatusEvent(event:NetStatusEvent):Boolean {            return true;        }        private function detect():void {            log.debug("connectServer()");            _detector.detect();        }        private function onClusterFailed(event:BandwidthDetectEvent):void {            log.debug("onClusterFailed(), will use default bitrate");            useDefaultBitrate();        }        private function onDetectorComplete(event:BandwidthDetectEvent):void {            event.stopPropagation();            log.info("\n\n kbit Down: " + event.info.kbitDown + " Delta Down: " + event.info.deltaDown + " Delta Time: " + event.info.deltaTime + " Latency: " + event.info.latency);            _hasDetectedBW = true;            // Set the detected bandwidth            var bandwidth:Number = event.info.kbitDown;            var mappedBitrate:BitrateItem = getMappedBitrate(bandwidth);            log.debug("bandwidth (kbitDown) " + bandwidth);            log.info("mapped to bitrate " + mappedBitrate.bitrate);            // Store the bitrate to prevent further bitrate detections            rememberBandwidth(bandwidth);            onBandwidthDetected(mappedBitrate, bandwidth);        }        private function get bitrateItems():Vector.<DynamicStreamingItem> {            return _streamSelection.bitrates;        }        private function getMappedBitrate(bandwidth:Number = -1):BitrateItem {            if (bandwidth == -1) return _streamSelection.getDefaultStream(_player) as BitrateItem;            return _streamSelection.getStream(bandwidth, _player) as BitrateItem;        }        private function getMappedBitrateFromIndex(index:Number):BitrateItem {            return _streamSelection.getStream(bitrateItems[index].bitrate, _player) as BitrateItem;        }        private function useDefaultBitrate():void {            log.info("using default bitrate because of an error with the bandwidth check");            onBandwidthDetected(getMappedBitrate(), -1);        }        private function onBandwidthDetected(mappedBitrate:BitrateItem, detectedBitrate:Number = -1):void {            log.debug("onBandwidthDetected()");            _currentBitrateItem = mappedBitrate;            dynamicBuffering(mappedBitrate.bitrate, detectedBitrate);            if (_playButton && _playButton.hasOwnProperty("stopBuffering")) {                _playButton["stopBuffering"]();            }            if (_resolving) {                changeStreamNames(mappedBitrate);                _resolveSuccessListener(_clip);                _resolving = false;            } else if (_netStream && (_player.isPlaying() || _player.isPaused())) {                switchStream(mappedBitrate);            } else {                changeStreamNames(mappedBitrate);            }            log.debug("dispatching onBwDone, mapped bitrate: " + mappedBitrate.bitrate + " detected bitrate " + detectedBitrate + " url: " + _clip.url);            _model.dispatch(PluginEventType.PLUGIN_EVENT, "onBwDone", mappedBitrate, detectedBitrate);        }        private function changeStreamNames(mappedBitrate:BitrateItem):void {            _previousStreamName = _clip.url;            _currentBitrateItem = mappedBitrate;            var url:String = getClipUrl(_clip, mappedBitrate);            _clip.setResolvedUrl(this, url);            _clip.setCustomProperty("bwcheckResolvedUrl", url);            _clip.setCustomProperty("mappedBitrate", mappedBitrate);            log.debug("mappedUrl " + url + ", clip.url now " + _clip.url);        }        private function switchStream(mappedBitrate:BitrateItem):void {            _currentBitrateItem = mappedBitrate;            log.debug("switchStream");            changeStreamNames(mappedBitrate);            if (_netStream && _netStream.hasOwnProperty("play2") && _config.dynamic) {                switchStreamDynamic(mappedBitrate);            } else {                log.debug("calling switchStream");                _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitch", mappedBitrate, _clip.url, _previousStreamName);                _player.switchStream(_clip);            }        }        private function onDynamicStreamStatus(event:NetStatusEvent):void {            switch (event.info.code) {                case "NetStream.Play.Transition":                    _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitch", _dynamicBitrateItem, event.info.details, _dynamicOldStreamName);                    break;            }        }        private function switchStreamDynamic(bitrate:BitrateItem):void {            _netStream.addEventListener(NetStatusEvent.NET_STATUS, onDynamicStreamStatus);            log.debug("doing a dynamic switch");            var options:NetStreamPlayOptions = new NetStreamPlayOptions();            if (_previousStreamName) {                options.oldStreamName = _previousStreamName;                options.transition = NetStreamPlayTransitions.SWITCH;            } else {                options.transition = NetStreamPlayTransitions.RESET;            }            options.streamName = _clip.url;            _dynamicStreamName = options.streamName;            _dynamicOldStreamName = options.oldStreamName;            _dynamicBitrateItem = bitrate;            log.debug("calling switchStream with Dynamic Switch Streaming, stream name is " + options.streamName);            //_player.switchStream(_clip, options);            _netStream.play2(options);        }        private function getDefaultSwitchingRules(metrics:RTMPNetStreamMetrics):Vector.<SwitchingRuleBase> {            var rules:Vector.<SwitchingRuleBase> = new Vector.<SwitchingRuleBase>();            rules.push(new SufficientBandwidthRule(metrics));            rules.push(new InsufficientBandwidthRule(metrics));            rules.push(new DroppedFramesRule(metrics));            rules.push(new InsufficientBufferRule(metrics));            rules.push(new ScreenSizeRule(metrics, _streamSelection, _player));            return rules;        }        protected function buildBitrateList(clip:Clip):void {            log.debug("buildBitrateList()");            if (clip.getCustomProperty("bitrateItems")) {                log.debug("buildBitrateList(), bitrates already initialized, returning");                return;            }            if (! clip.getCustomProperty("bitrates")) {                return;            }            var items:Array = new Array();            for each(var props:Object in clip.getCustomProperty("bitrates")) {                var bitrate:BitrateItem = new BitrateItem();                for (var key:String in props) {                    if (bitrate.hasOwnProperty(key)) bitrate[key] = props[key];                }                items.push(bitrate);            }            clip.setCustomProperty("bitrateItems", items);            // TODO: do we need both bitrateItems and streamingItems ??            var streamingItems:Vector.<DynamicStreamingItem> = new Vector.<DynamicStreamingItem>();            for (var i:int = 0; i < items.length; i++) {                var aBitrateItem:BitrateItem = items[i];                //                log.debug("bitrate ID " + i + ": "+ aBitrateItem.bitrate + ": " + aBitrateItem.url + ", width: " + aBitrateItem.width);                // initialize the index value                aBitrateItem.index = i;                if (aBitrateItem.hd) {                    _hasHD = true;                    _hdIndex = i;                }                streamingItems.push(aBitrateItem);            }            _streamSelection = new StreamSelectionFactory(_config, streamingItems);            log.debug("ordered bitrate list");            for each (var itemInOrder:Object in _streamSelection.bitrates) {                log.debug("item", itemInOrder);            }        }        /**         * Store the detection and chosen bitrate if the rememberBitrate config property is set.         */        protected function rememberBandwidth(bw:int):void {            if (_config.rememberBitrate) {                _bitrateStorage.bandwidth = bw;                log.debug("stored bandwidth " + bw);            }        }        private function isRememberedBitrateValid():Boolean {            log.debug("isRememberedBitrateValid()");            if (! _bitrateStorage.bandwidth) {                log.debug("bandwidth not in SO");                return false;            }            var expired:Boolean = _bitrateStorage.isExpired;            log.debug("is remembered bitrate expired?: " + expired + (expired ? ", age is " + _bitrateStorage.age : ""));            return ! expired;        }        /**         * Callback from QOS Monitor.         * @param event         * @return         */        protected function onSwitchStream(event:DynamicStreamEvent):void {            var mappedBitrate:BitrateItem = getMappedBitrateFromIndex(event.info.streamID);            rememberBandwidth(event.info.maxBandwidth);            dynamicBuffering(mappedBitrate.bitrate, event.info.maxBandwidth);            switchStream(mappedBitrate);        }        public function resolve(provider:StreamProvider, clip:Clip, successListener:Function):void {            log.debug("resolve " + clip);            if (clip.getCustomProperty("bitrates") == null) {                log.debug("Bitrates configuration not enabled for this clip");                successListener(clip);                return;            }            if (alreadyResolved(clip)) {                log.debug("resolve(): bandwidth already resolved for clip " + clip + ", will not detect again");                successListener(clip);                return;            }            _provider = provider;            _resolving = true;            _resolveSuccessListener = successListener;            init(provider.netStream, clip);            buildBitrateList(clip);            checkBandwidthIfNotDetectedYet();        }        private function dynamicBuffering(mappedBitrate:Number, detectedBitrate:Number):void {            if (_config.enableDynamicBuffer) {                _clip.onMetaData(function(event:ClipEvent):void {                    _clip.bufferLength = BufferCalculator.calculate(_clip.metaData.duration, mappedBitrate, detectedBitrate);                    log.debug("Dynamically setting buffer time to " + _clip.bufferLength + "s");                });            }        }        private function checkBandwidthIfNotDetectedYet():void {            if (! applyForClip(_player.playlist.current)) return;            if (hasDetectedBW()) {                var mappedBitrate:BitrateItem = getMappedBitrate(_bitrateStorage.bandwidth);                log.info("using remembered bandwidth " + _bitrateStorage.bandwidth + ", maps to bitrate " + mappedBitrate.bitrate);                onBandwidthDetected(mappedBitrate, _bitrateStorage.bandwidth);            } else if (_initFailed) {                useDefaultBitrate();            } else if (_config.dynamic && !_config.checkOnStart) {                log.info("using dynamic switching with default bitrate ");                onBandwidthDetected(getMappedBitrate(), -1);            } else if (_config.checkOnStart) {                log.debug("not using remembered bandwidth, detecting now");                detect();            }        }        private function init(netStream:NetStream, clip:Clip):void {            log.debug("init(), netStream.client " + (netStream ? netStream.client : null))                    ;            _netStream = netStream;            _clip = clip;            _start = netStream ? netStream.time : 0;            buildBitrateList(clip);        }        private function initQoS(netStream:NetStream, clip:Clip):void {            log.debug("initQoS(), netStream == " + netStream + ", host == " + _detector.host);            if (dsResource) {                log.debug("initQos(), QoS alsready initialized");                return;            }            netStream.client = new OsmfNetStreamClient(NetStreamClient(netStream.client));            netStream.addEventListener(NetStatusEvent.NET_STATUS, onDynamicStreamStatus);            dsResource = new DynamicStreamingResource(_detector.host);            dsResource.streamItems = Vector.<org.osmf.net.DynamicStreamingItem>(bitrateItems);            // TODO: what is the correct initial index?            dsResource.initialIndex = _currentBitrateItem ? _streamSelection.bitrates.indexOf(_currentBitrateItem) : 0;            var metrics:RTMPNetStreamMetrics = new RTMPNetStreamMetrics(netStream);            metrics.resource = dsResource;            _switchManager = new NetStreamSwitchManager(_provider.netConnection, netStream, dsResource, metrics, getDefaultSwitchingRules(metrics));            _switchManager.autoSwitch = true;            metrics.startMeasurements();        }        protected function getClipUrl(clip:Clip, mappedBitrate:BitrateItem):String {            log.info("Resolved stream url: " + mappedBitrate.url);            return mappedBitrate.url;            //return (clip.baseUrl ? URLUtil.completeURL(clip.baseUrl, mappedBitrate.url) : mappedBitrate.url);        }        private function checkCurrentClip():Boolean {            var clip:Clip = _player.playlist.current;            if (_clip == clip) return true;            if (clip.urlResolvers && clip.urlResolvers.indexOf(_model.name) < 0) {                return false;            }            _clip = clip;            return true;        }        private function initAutoHide():void {            _autoHide = new AutoHide(null, _config.autoHide, _player, stage, _iconBar);            _autoHide.hide();            _autoHide.onShow(onButtonsShow);            _autoHide.start();        }        private function onPlayerLoad(event:PlayerEvent):void {            _autoHide = new AutoHide(null, _config.autoHide, _player, stage, _iconBar);            _autoHide.hide();            _autoHide.onShow(onButtonsShow);            _autoHide.start();        }        private function createIconBar():void {            _iconBar = new IconBar(_config, _player, _hasHD);            _iconBar.onHd(function(isHD:Boolean):void {                //log.error(isHD.toString());            });        }        private function onButtonsShow():Boolean {            return _hasHD;            //return _hdIndex > 0;            //return ! this.visible || this.alpha == 0;        }        [External]        public function checkBandwidth():void {            log.debug("checkBandwidth");            if (! checkCurrentClip()) return;            _start = _provider ? _provider.time : 0;            _hasDetectedBW = false;            _bitrateStorage.clear();            detect();        }        [External]        public function setBitrate(bitrate:Number):void {            log.debug("set bitrate()");            if (! checkCurrentClip()) return;            try {                if (_player.isPlaying() || _player.isPaused()) {                    switchStream(getMappedBitrate(bitrate));                    //destroyQosMonitor();                }            } catch (e:Error) {                log.error("error when switching streams " + e);            }        }        [External]        public function enableDynamic(enabled:Boolean):void {            log.debug("set dynamic(), currently " + _config.dynamic + ", new value" + enabled);            if (_config.dynamic == enabled) return;            _config.dynamic = enabled;            // TODO: implement this            if (enabled) {                //initQosMonitor();            } else {                //destroyQosMonitor();            }        }        [External]        public function get labels():Object {            if (! bitrateItems) {                buildBitrateList(_player.playlist.current);            }            var labels:Object = {};            for (var i:int = 0; i < bitrateItems.length; i++) {                var item:BitrateItem = bitrateItems[i] as BitrateItem;                if (item.label) {                    labels[item.bitrate] = item.label;                }            }            return labels;        }        [External]        public function getSelectionStrategy():String {            return _config.streamSelectionStrategy;        }        [External]        public function get bitrate():Number {            log.debug("get bitrate()");            if (! checkCurrentClip()) return undefined;            if (_config.rememberBitrate && _bitrateStorage.bandwidth >= 0) {                log.debug("get bitrate(), returning remembered bandwidth");                var mappedBitrate:BitrateItem = getMappedBitrate(_bitrateStorage.bandwidth);                return mappedBitrate.bitrate;            }            log.debug("get bitrate(), returning current bitrate");            return _currentBitrateItem.bitrate;        }        public function getDefaultConfig():Object {            return null;        }    }}