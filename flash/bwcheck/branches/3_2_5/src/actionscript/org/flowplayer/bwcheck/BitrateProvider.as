/* * This file is part of Flowplayer, http://flowplayer.org * * By: Daniel Rossi <electroteque@gmail.com>, Anssi Piirainen <api@iki.fi> Flowplayer Oy * Copyright (c) 2009, 2010 Electroteque Multimedia, Flowplayer Oy * * Released under the MIT License: * http://www.opensource.org/licenses/mit-license.php */package org.flowplayer.bwcheck {import de.betriebsraum.video.BufferCalculator;import flash.display.DisplayObject;import flash.events.NetStatusEvent;import flash.net.NetStream;import flash.net.NetStreamPlayOptions;import flash.net.NetStreamPlayTransitions;    import flash.utils.Dictionary;    import fp.HDSymbol;import org.flowplayer.bwcheck.config.Config;import org.flowplayer.bwcheck.detect.BandwidthDetectEvent;import org.flowplayer.bwcheck.detect.BandwidthDetector;import org.flowplayer.bwcheck.detect.ScreenSizeRule;import org.flowplayer.bwcheck.detect.StreamSelector;import org.flowplayer.bwcheck.ui.HDToggleController;import org.flowplayer.controller.ClipURLResolver;import org.flowplayer.controller.NetStreamClient;import org.flowplayer.controller.StreamProvider;import org.flowplayer.model.Clip;import org.flowplayer.model.ClipEvent;import org.flowplayer.model.PlayerEvent;import org.flowplayer.model.Plugin;import org.flowplayer.model.PluginEventType;import org.flowplayer.model.PluginModel;import org.flowplayer.net.BitrateItem;import org.flowplayer.ui.Dock;import org.flowplayer.ui.Notification;import org.flowplayer.ui.buttons.ToggleButton;import org.flowplayer.ui.buttons.ToggleButtonConfig;import org.flowplayer.ui.containers.*;import org.flowplayer.util.Arrange;import org.flowplayer.util.PropertyBinder;import org.flowplayer.view.AbstractSprite;import org.flowplayer.view.Flowplayer;import org.flowplayer.view.Styleable;import org.osmf.logging.Log;import org.osmf.net.DynamicStreamingItem;import org.osmf.net.DynamicStreamingResource;import org.osmf.net.NetStreamSwitchManager;import org.osmf.net.SwitchingRuleBase;CONFIG::enableRtmpMetrics {    import org.osmf.net.rtmpstreaming.RTMPNetStreamMetrics;    import org.osmf.net.rtmpstreaming.DroppedFramesRule;    import org.osmf.net.rtmpstreaming.InsufficientBandwidthRule;    import org.osmf.net.rtmpstreaming.InsufficientBufferRule;    import org.osmf.net.rtmpstreaming.SufficientBandwidthRule;}CONFIG::enableHttpMetrics {    import org.osmf.net.rtmpstreaming.DroppedFramesRule;    import org.osmf.net.httpstreaming.HTTPNetStreamMetrics;    import org.osmf.net.httpstreaming.DownloadRatioRule;    import org.osmf.net.httpstreaming.HTTPNetStream;}public class BitrateProvider extends AbstractSprite implements ClipURLResolver, Plugin, Styleable {    private var _config:Config;    private var _netStream:NetStream;    private var _resolveSuccessListener:Function;    private var _failureListener:Function;    private var _clip:Clip;    private var _hasDetectedBW:Boolean = false;    private var _start:Number = 0;    private var _model:PluginModel;    private var _previousStreamName:String;    private var _player:Flowplayer;    private var _resolving:Boolean;    private var _playButton:DisplayObject;    private var _provider:StreamProvider;    private var _dynamicOldStreamName:String;    private var _bitrateStorage:BitrateStorage;    private var _streamSelector:StreamSelector;    private var _detector:BandwidthDetector;    private var _switchManager:NetStreamSwitchManager;    private var dsResource:DynamicStreamingResource;    private var _iconDock:Dock;    private var _previousBitrateItem:BitrateItem;    private var _isDynamic:Boolean;    private var _hdButton:ToggleButton;    private var _hasHdButton:Boolean;    private var _hdEnabled:Boolean = false;    public function onConfig(model:PluginModel):void {        log.debug("onConfig(_)");        Log.loggerFactory = new OsmfLoggerFactory();        _config = new PropertyBinder(new Config()).copyProperties(model.config) as Config;        _model = model;        _bitrateStorage = new BitrateStorage(_config.bitrateProfileName, "/");        _bitrateStorage.expiry = _config.cacheExpiry;        log.debug("onConfig(), dynamic " + _config.dynamic);    }    private function applyForClip(clip:Clip):Boolean {        var bw:Object = clip.getCustomProperty("bwcheck");        log.debug("applyForClip() ? " + bw);        if (bw is Boolean && ! bw) return false;        return true;    }    private function canSwitchOnFullscreen():Boolean {        return _config.switchOnFullscreen && _player.streamProvider.type != "http" && hasHD;    }    public function onLoad(player:Flowplayer):void {        log.debug("onLoad()");        _player = player;        lookupProvider(player.pluginRegistry.providers);        _detector = new BandwidthDetector(_model, _config, _player.playlist);        _detector.addEventListener(BandwidthDetectEvent.DETECT_COMPLETE, onDetectorComplete);        _detector.addEventListener(BandwidthDetectEvent.CLUSTER_FAILED, onClusterFailed);        if (canSwitchOnFullscreen()) {            _player.onFullscreen(onFullscreen);            _player.onFullscreenExit(onFullscreen);        }        _player.playlist.onBeforeBegin(function(event:ClipEvent):void {            var clip:Clip = event.target as Clip;            //fixes for smil resolver, check if we have dynamicStreamingItems set to reuse streamselector.            if (clip.getCustomProperty("bitrateItems")) {                //collect the stream selector when replaying clips in a playlist                _streamSelector = new StreamSelector(clip.getCustomProperty("bitrateItems") as Vector.<DynamicStreamingItem>, _player, _config);            }        }, applyForClip);        _player.playlist.onStart(function(event:ClipEvent):void {            log.debug("onStart()");            var clip:Clip = event.target as Clip;            if (alreadyResolved(clip)) {                init(clip.getNetStream(), clip);                if (_config.dynamic) {                    initQoS(clip.getNetStream(), clip);                }                log.debug("hd available? " + hasHD);                dispatchEvent(new HDEvent(HDEvent.HD_AVAILABILITY, hasHD));                toggleDefaultToHD(currentItem());            }        }, applyForClip);        var autoSwitch:Function = function(enable:Boolean):Function {            return function(event:ClipEvent):void {                if (! _switchManager) return;                var newVal:Boolean = _config.dynamic && enable;                log.debug("setting QOS state to " + newVal);                _switchManager.autoSwitch = newVal;            }        };        _player.playlist.onPause(autoSwitch(false), applyForClip);        _player.playlist.onStop(autoSwitch(false), applyForClip);        _player.playlist.onStart(autoSwitch(true), applyForClip);        _player.playlist.onResume(autoSwitch(true)),applyForClip;        _player.playlist.onFinish(autoSwitch(false), applyForClip);        if (!_config.dynamic) {            if (_config.hdButton.docked) {                _hasHdButton = true;                createIconDock();	// we need to create the controller pretty early else it won't receive the HD_AVAILABILITY event                _player.onLoad(onPlayerLoad);            }            if (_config.hdButton.controls) {                _hasHdButton = true;                var controlbar:* = player.pluginRegistry.plugins['controls'];                controlbar.pluginObject.addEventListener(WidgetContainerEvent.CONTAINER_READY, addHDButton);            }        }        _model.dispatchOnLoad();    }    private function onPlayerLoad(event:PlayerEvent):void {        log.debug("onPlayerLoad() ");        _iconDock.addToPanel();    }    private function addHDButton(event:WidgetContainerEvent):void {        var container:WidgetContainer = event.container;        var controller:HDToggleController = new HDToggleController(false, this);        container.addWidget(controller, "volume", false);    }    private function createIconDock():void {        if (_iconDock) return;        _iconDock = Dock.getInstance(_player);        var controller:HDToggleController = new HDToggleController(true, this);        // dock should do that, v3.2.7 maybe :)        _hdButton = controller.init(_player, _iconDock, new ToggleButtonConfig(_config.iconConfig, _config.iconConfig)) as ToggleButton;        _iconDock.addIcon(_hdButton);        _iconDock.addToPanel();    }    public function get hasHD():Boolean {        return (_player.playlist.current.getCustomProperty("hdBitrateItem") && _player.playlist.current.getCustomProperty("sdBitrateItem"));    }    public function set hd(enable:Boolean):void {        if (! hasHD) return;        log.info("set HD, switching to " + (enable ? "HD" : "normal"));        var newItem:BitrateItem = _player.playlist.current.getCustomProperty(enable ? "hdBitrateItem" : "sdBitrateItem") as BitrateItem;        switchStream(newItem);        setHDNotification(enable);    }    private function setHDNotification(enable:Boolean):void {        _hdEnabled = enable;        if (_config.hdButton.splash) {            displayHDNotification(enable);        }        dispatchEvent(new HDEvent(HDEvent.HD_SWITCHED, _hdEnabled));    }    private function displayHDNotification(enable:Boolean):void {        var symbol:HDSymbol = new HDSymbol();        symbol.hdText.text = enable ? _config.hdButton.onLabel : _config.hdButton.offLabel;        symbol.hdText.width = symbol.hdText.textWidth + 26;        Arrange.center(symbol.hdText, symbol.width);        Arrange.center(symbol.hdSymbol, symbol.width);        var notification:Notification = Notification.createDisplayObjectNotification(_player, symbol);        notification.show(_config.hdButton.splash).autoHide(1200);    }    private function toggleDefaultToHD(mappedBitrate:BitrateItem):void {        if (mappedBitrate.isDefault) toggleToHD(mappedBitrate);    }    private function toggleToHD(mappedBitrate:BitrateItem):void {        if (mappedBitrate.hd) setHDNotification(true);    }    public function get hd():Boolean {        return _hdEnabled;    }    private function onFullscreen(event:PlayerEvent):void {        log.debug("onFullscreen(), checking bandwidth and switching stream");        //remember the previous stream to determine if we should change the bitrate        _previousBitrateItem = currentItem();        //_previousStreamName = currentItem().streamName;        checkBandwidthIfNotDetectedYet();    }    private function alreadyResolved(clip:Clip):Boolean {        return clip.getCustomProperty("bwcheckResolvedUrl") != null;    }    protected function hasDetectedBW():Boolean {        if (! _config.rememberBitrate) return false;        if (_hasDetectedBW) return true;        if (isRememberedBitrateValid()) return true;        return false;    }    public function set onFailure(listener:Function):void {        _failureListener = listener;    }    public function handeNetStatusEvent(event:NetStatusEvent):Boolean {        return true;    }    private function detect():void {        log.debug("connectServer()");        _detector.detect();    }    private function onClusterFailed(event:BandwidthDetectEvent):void {        log.error("onClusterFailed(), will use default bitrate");        useDefaultBitrate();    }    private function onDetectorComplete(event:BandwidthDetectEvent):void {        log.debug("onDetectorComplete()");        event.stopPropagation();        log.info("\n\n kbit Down: " + event.info.kbitDown + " Delta Down: " + event.info.deltaDown + " Delta Time: " + event.info.deltaTime + " Latency: " + event.info.latency);        _hasDetectedBW = true;        // Set the detected bandwidth        var bandwidth:Number = event.info.kbitDown;        var mappedBitrate:BitrateItem = getMappedBitrate(bandwidth);        log.debug("bandwidth (kbitDown) " + bandwidth);        log.info("mapped to bitrate " + mappedBitrate.bitrate);        rememberBandwidth(bandwidth);        //fix for #232 toggles hd clip on detection        toggleToHD(mappedBitrate);        selectBitrate(mappedBitrate, bandwidth);    }    private function getMappedBitrate(bandwidth:Number = -1):BitrateItem {        if (bandwidth == -1) return streamSelector.getDefaultStream() as BitrateItem;        return streamSelector.getStream(bandwidth) as BitrateItem;    }    private function dynamicBuffering(mappedBitrate:Number, detectedBitrate:Number):void {        if (_config.dynamicBuffer) {            _clip.onMetaData(function(event:ClipEvent):void {                _clip.bufferLength = BufferCalculator.calculate(_clip.metaData.duration, mappedBitrate, detectedBitrate);                log.debug("Dynamically setting buffer time to " + _clip.bufferLength + "s");            });        }    }    private function selectBitrate(mappedBitrate:BitrateItem, detectedBitrate:Number = -1):void {        log.debug("selectBitrate()");        //don't switch unless the stream / bitrate is different.        if (_previousBitrateItem && mappedBitrate.streamName == _previousBitrateItem.streamName) {            log.debug("mapped bitrate name: " + mappedBitrate.streamName + " matches current stream " + _previousBitrateItem.streamName + " will not switch");            return;        }        dynamicBuffering(mappedBitrate.bitrate, detectedBitrate);        if (_playButton && _playButton.hasOwnProperty("stopBuffering")) {            _playButton["stopBuffering"]();        }        //move this event up to give it time before onStreamSwitchBegin is called.        log.debug("dispatching onBwDone, mapped bitrate: " + mappedBitrate.bitrate + " detected bitrate " + detectedBitrate + " url: " + _clip.url);        _model.dispatch(PluginEventType.PLUGIN_EVENT, "onBwDone", mappedBitrate, detectedBitrate);        if (_resolving) {            changeStreamNames(mappedBitrate);            _resolveSuccessListener(_clip);            _resolving = false;        } else if (_netStream && (_player.isPlaying() || _player.isPaused())) {            switchStream(mappedBitrate);        } else {            changeStreamNames(mappedBitrate);        }        _previousBitrateItem = mappedBitrate;    }    private function changeStreamNames(mappedBitrate:BitrateItem):void {        var url:String = getClipUrl(_clip, mappedBitrate);        //we need to pickup the first actual resolved clip not what is set in clip.url.        _previousStreamName = _previousStreamName ? _clip.url : url;        _clip.setResolvedUrl(this, url);        _clip.setCustomProperty("bwcheckResolvedUrl", url);        _clip.setCustomProperty("mappedBitrate", mappedBitrate);        log.debug("mappedUrl " + url + ", clip.url now " + _clip.url);    }    private function switchStream(mappedBitrate:BitrateItem):void {        log.debug("switchStream(), provider type is " + _provider.type);        changeStreamNames(mappedBitrate);        //resume stream before switching        if (_player.isPaused()) _player.resume();        //set the index of streamselector or else currentItem won't update correctly        streamSelector.currentIndex = mappedBitrate.index;        if (_netStream && _netStream.hasOwnProperty("play2") && (_provider.type == "rtmp" || _provider.type == "httpstreaming")) {            //set the index of switchManager or else currentItem won't update correctly            if (_switchManager) _switchManager.currentIndex = mappedBitrate.index;            switchStreamDynamic(mappedBitrate);        } else {            switchStreamNative(mappedBitrate);        }    }    private function switchStreamNative(mappedBitrate:BitrateItem):void {        log.debug("new item is " + mappedBitrate + ", current " + _previousBitrateItem);        _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitchBegin", mappedBitrate, _previousBitrateItem);        _player.switchStream(_clip);    }    private function switchStreamDynamic(bitrate:BitrateItem):void {        log.debug("switchStreamDynamic()");        //_netStream.addEventListener(NetStatusEvent.NET_STATUS, onNetStreamStatus);        var options:NetStreamPlayOptions = new NetStreamPlayOptions();        if (_previousStreamName) {            options.oldStreamName = _previousStreamName;            options.transition = NetStreamPlayTransitions.SWITCH;        } else {            options.transition = NetStreamPlayTransitions.RESET;        }        options.streamName = _clip.url;        _dynamicOldStreamName = options.oldStreamName;        log.debug("calling switchStream with Dynamic Switch Streaming, stream name is " + options.streamName);        //_player.switchStream(_clip, options);        _netStream.play2(options);    }    private function addRule(prop:String, rules:Vector.<SwitchingRuleBase>, rule:SwitchingRuleBase):void {        if (_config.qos[prop]) {            log.debug("using QoS switching rules " + rule);            rules.push(rule);        }    }    protected function buildBitrateList(clip:Clip):void {        log.debug("buildBitrateList()");        if (clip.getCustomProperty("streamSelector")) {            log.debug("buildBitrateList(), bitrates and stream selector already initialized, returning");            return;        }        if (! clip.getCustomProperty("bitrates") && !clip.getCustomProperty("bitrateItems")) {            return;        }        var streamingItems:Vector.<DynamicStreamingItem>;        if (!clip.getCustomProperty("bitrateItems")) {            streamingItems = new Vector.<DynamicStreamingItem>();            var i:int = 0;            for each(var props:Object in clip.getCustomProperty("bitrates")) {                var bitrateItem:BitrateItem = new PropertyBinder(new BitrateItem()).copyProperties(props) as BitrateItem;                bitrateItem.index = i;                streamingItems.push(bitrateItem);                i++;            }            //set the DynamicStreamingItem to the clip to be reused later in the streamselector            clip.setCustomProperty("bitrateItems", streamingItems);        } else {            //we have a bitrateItems list configured in another plugin            streamingItems = Vector.<DynamicStreamingItem>(clip.getCustomProperty("bitrateItems"));        }        _streamSelector = new StreamSelector(streamingItems, _player, _config);        // fix for #232 refactor HD button feature if the hd dock/controls icon is set and two bitrates are configured        log.debug("NUMBER OF BITRATE ITEMS: " + this.bitrateItems.length);        if (this.bitrateItems.length == 2 && _hasHdButton) {            //set this item to a hd clip            var hdItem:BitrateItem = bitrateItems[bitrateItems.length - 1] as BitrateItem;            hdItem.hd = true;            //set this item to a sd clip            var sdItem:BitrateItem = bitrateItems[0] as BitrateItem;            sdItem.sd = true;            clip.setCustomProperty("hdBitrateItem", hdItem);            clip.setCustomProperty("sdBitrateItem", sdItem);            log.debug("HD feature is set, SD Bitrate: " + sdItem.bitrate + " HD Bitrate: " + hdItem.bitrate);        }        clip.setCustomProperty("streamSelector", _streamSelector);    }    [External]    public function get bitrateItems():Vector.<DynamicStreamingItem> {        return streamSelector.bitrates;    }    /**     * Store the detection and chosen bitrate if the rememberBitrate config property is set.     */    protected function rememberBandwidth(bw:int):void {        if (_config.rememberBitrate) {            _bitrateStorage.bandwidth = bw;            log.debug("stored bandwidth " + bw);        }    }    private function isRememberedBitrateValid():Boolean {        log.debug("isRememberedBitrateValid()");        if (! _bitrateStorage.bandwidth) {            log.debug("bandwidth not in SO");            return false;        }        var expired:Boolean = _bitrateStorage.isExpired;        log.debug("is remembered bitrate expired?: " + expired + (expired ? ", age is " + _bitrateStorage.age : ""));        return ! expired;    }    public function resolve(provider:StreamProvider, clip:Clip, successListener:Function):void {        log.debug("resolve " + clip);        if (!clip.getCustomProperty("bitrates") && !clip.getCustomProperty("bitrateItems")) {            log.debug("Bitrates configuration not enabled for this clip");            successListener(clip);            return;        }        if (alreadyResolved(clip)) {            log.debug("resolve(): bandwidth already resolved for clip " + clip + ", will not detect again");            successListener(clip);            return;        }        _provider = provider;        _resolving = true;        _resolveSuccessListener = successListener;        init(provider.netStream, clip);        checkBandwidthIfNotDetectedYet();    }    private function useDefaultBitrate():void {        var mappedBitrate:BitrateItem = getMappedBitrate();        selectBitrate(mappedBitrate, -1);        //toggleDefaultToHD(mappedBitrate);    }    private function useStoredBitrate():void {        var mappedBitrate:BitrateItem = getMappedBitrate(_bitrateStorage.bandwidth);        log.info("using remembered bandwidth " + _bitrateStorage.bandwidth + ", maps to bitrate " + mappedBitrate.bitrate);        selectBitrate(mappedBitrate, _bitrateStorage.bandwidth);    }    private function checkBandwidthIfNotDetectedYet():void {        if (! applyForClip(_player.playlist.current)) return;        if (hasDetectedBW()) {            useStoredBitrate();        } else if (_config.checkOnStart) {            log.debug("not using remembered bandwidth, detecting now");            detect();        } else {            log.info("using dynamic switching with default bitrate ");            useDefaultBitrate();        }    }    private function init(netStream:NetStream, clip:Clip):void {        log.debug("init(), netStream == " + netStream);        _netStream = netStream;        _clip = clip;        _start = netStream ? netStream.time : 0;        if (netStream && ! (netStream.client is OsmfNetStreamClient)) {            var netStreamClient:OsmfNetStreamClient = new OsmfNetStreamClient(NetStreamClient(netStream.client));            netStreamClient.onTransitionComplete = onTransitionComplete;            netStream.client = netStreamClient;            netStream.addEventListener(NetStatusEvent.NET_STATUS, onNetStreamStatus);        }        //clear this for each playlist item, used to compare bitrates to prevent switching #194        _previousBitrateItem = null;        buildBitrateList(clip);    }    private function initQoS(netStream:NetStream, clip:Clip):void {        log.debug("initQoS(), netStream == " + netStream + ", host == " + _detector.host);        import org.osmf.net.StreamType;        //save the streaming resource and load for each clip in the playlist        if (clip.getCustomProperty("urlResource")) {            dsResource = clip.getCustomProperty("urlResource") as DynamicStreamingResource;            dsResource.initialIndex = streamSelector.currentIndex;        } else {            dsResource = null;            dsResource = new DynamicStreamingResource(_detector.host);            dsResource.streamItems = Vector.<DynamicStreamingItem>(bitrateItems);            dsResource.initialIndex = streamSelector.currentIndex;            dsResource.streamType = _config.live ? StreamType.LIVE : StreamType.RECORDED;            clip.setCustomProperty("urlResource", dsResource);        }        setupMetrics(netStream);    }    private function setupMetrics(netStream:NetStream):void {        CONFIG::enableRtmpMetrics {            if (_provider.type == "rtmp") {                var rtmpMetrics:RTMPNetStreamMetrics = new RTMPNetStreamMetrics(netStream);                rtmpMetrics.resource = dsResource;                _switchManager = new NetStreamSwitchManager(_provider.netConnection, netStream, dsResource, rtmpMetrics, getRTMPSwitchingRules(rtmpMetrics));                log.debug("using switch manager " + _switchManager);                _switchManager.autoSwitch = true;                rtmpMetrics.startMeasurements();            }        }        CONFIG::enableHttpMetrics {            if (_provider.type == "httpstreaming") {                HTTPNetStream(netStream).manualSwitchMode = false;                var httpMetrics:HTTPNetStreamMetrics = new HTTPNetStreamMetrics(netStream as HTTPNetStream);                httpMetrics.resource = dsResource;                _switchManager = new NetStreamSwitchManager(_provider.netConnection, netStream, dsResource, httpMetrics, getHTTPSwitchingRules(httpMetrics));                _switchManager.autoSwitch = true;                httpMetrics.startMeasurements();            }        }    }    CONFIG::enableRtmpMetrics {        private function getRTMPSwitchingRules(metrics:RTMPNetStreamMetrics):Vector.<SwitchingRuleBase> {            var rules:Vector.<SwitchingRuleBase> = new Vector.<SwitchingRuleBase>();            addRule("bwUp", rules, new SufficientBandwidthRule(metrics));            addRule("bwDown", rules, new InsufficientBandwidthRule(metrics));            addRule("frames", rules, new DroppedFramesRule(metrics));            addRule("buffer", rules, new InsufficientBufferRule(metrics));            addRule("screen", rules, new ScreenSizeRule(metrics, streamSelector, _player, _config));            return rules;        }    }    CONFIG::enableHttpMetrics {        private function getHTTPSwitchingRules(metrics:HTTPNetStreamMetrics):Vector.<SwitchingRuleBase> {            var rules:Vector.<SwitchingRuleBase> = new Vector.<SwitchingRuleBase>();            addRule("ratio", rules, new DownloadRatioRule(metrics));            addRule("frames", rules, new DroppedFramesRule(metrics));            addRule("screen", rules, new ScreenSizeRule(metrics, streamSelector, _player, _config));            return rules;        }    }    private function onNetStreamStatus(event:NetStatusEvent):void {        log.info("onNetStreamStatus() -- " + event.info.code);        switch (event.info.code) {            case "NetStream.Play.Transition":                var newItem:DynamicStreamingItem = streamSelector.fromName(event.info.details);                log.debug("new item is " + newItem + ", (" + event.info.details + "), current " + _previousBitrateItem);                _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitchBegin", newItem, _previousBitrateItem);                break;            case "NetStream.Play.Failed":            case "NetStream.Failed":                //fix for #230                log.debug("Transition failed with error " + event.info.description);                _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitchFailed", "Transition failed with error " + event.info.description);                //fix for #247, will run a native switch on a transition failure.                switchStreamNative(currentItem());                break;        }    }    private function onTransitionComplete():void {        log.debug("onTransitionComplete()");        var currentItem:BitrateItem = currentItem();        _previousBitrateItem = currentItem;        _model.dispatch(PluginEventType.PLUGIN_EVENT, "onStreamSwitch", currentItem);    }    [External]    public function currentItem():BitrateItem {        log.debug("currentItem(), _switchManager.currentIndex: " + (_switchManager ? _switchManager.currentIndex : "no switch manager") + ", streamSelector.currentIndex: " + streamSelector.currentIndex );        return BitrateItem(streamSelector.streamItems[_switchManager ? _switchManager.currentIndex : streamSelector.currentIndex]);    }    protected function getClipUrl(clip:Clip, mappedBitrate:BitrateItem):String {        log.info("Resolved stream url: " + mappedBitrate.url);        return mappedBitrate.url;    }    private function checkCurrentClip():Boolean {        var clip:Clip = _player.playlist.current;        if (_clip == clip) return true;        if (clip.urlResolvers && clip.urlResolvers.indexOf(_model.name) < 0) {            return false;        }        _clip = clip;        return true;    }    [External]    public function checkBandwidth():void {        log.debug("checkBandwidth");        if (! checkCurrentClip()) return;        _start = _provider ? _provider.time : 0;        _hasDetectedBW = false;        _bitrateStorage.clear();        detect();    }    [External]    public function setBitrate(bitrate:Number):void {        log.debug("set bitrate()");        if (! checkCurrentClip()) return;        try {            if (_player.isPlaying() || _player.isPaused()) {                // fix for #231                _previousBitrateItem = currentItem();                switchStream(getMappedBitrate(bitrate));                _config.dynamic = false;                if (_switchManager) {                    _switchManager.autoSwitch = false;                }            }        } catch (e:Error) {            log.error("error when switching streams " + e);        }    }    [External]    public function enableDynamic(enabled:Boolean):void {        log.debug("set dynamic(), currently " + _config.dynamic + ", new value " + enabled);        if (_config.dynamic == enabled) return;        _config.dynamic = enabled;        if (enabled) {            if (! _switchManager) {                var clip:Clip = _player.playlist.current;                initQoS(clip.getNetStream(), clip);            }            _switchManager.autoSwitch = true;        } else {            if (_switchManager) {                _switchManager.autoSwitch = false;            }        }    }    [External]    public function get labels():Object {        if (! bitrateItems) {            buildBitrateList(_player.playlist.current);        }        var labels:Object = {};        for (var i:int = 0; i < bitrateItems.length; i++) {            var item:BitrateItem = bitrateItems[i] as BitrateItem;            if (item.label) {                labels[item.bitrate] = item.label;            }        }        return labels;    }    /**     * Gets the current bitrate. The returned value is the bitrate in use after the latest bitrate transition has been completed. If     * a transition is in progress the value reflects the bitrate right now being used, not the one we are changing to.     * @return     */    [External]    public function get bitrate():Number {        log.debug("get bitrate()");        if (! checkCurrentClip()) return undefined;        if (_config.rememberBitrate && _bitrateStorage.bandwidth >= 0) {            log.debug("get bitrate(), returning remembered bandwidth");            var mappedBitrate:BitrateItem = getMappedBitrate(_bitrateStorage.bandwidth);            return mappedBitrate.bitrate;        }        log.debug("get bitrate(), returning current bitrate");        return currentItem().bitrate;    }    public function getDefaultConfig():Object {        return {            top: "45%",            left: "50%",            opacity: 1,            borderRadius: 15,            border: 'none',            width: "80%",            height: "80%"        };    }    private function get streamSelector():StreamSelector {        if (! _streamSelector) {            buildBitrateList(_player.playlist.current);        }        return _streamSelector;    }    public function css(styleProps:Object = null):Object {        return {};    }    public function animate(styleProps:Object):Object {        return {};    }    public function onBeforeCss(styleProps:Object = null):void {        _iconDock.cancelAnimation();    }    public function onBeforeAnimate(styleProps:Object):void {        _iconDock.cancelAnimation();    }    private function lookupProvider(providers:Dictionary):void {        log.debug("lookupProvider() " + providers);        if (_config.provider) {            var model:PluginModel = _player.pluginRegistry.getPlugin(_config.provider) as PluginModel;            if (! model) throw new Error("Failed to find plugin '" + _config.provider + "'");            if (! (model.pluginObject is StreamProvider)) throw new Error("The specified provider is not a StreamProvider");            _provider = StreamProvider(model.pluginObject);            return;        }        for each (model in providers) {            log.debug(model.name);            if (model.name == "rtmp") {                _provider = StreamProvider(model.pluginObject);                return;            }            if (["http", "httpInstream"].indexOf(model.name) < 0 && model.pluginObject is StreamProvider) {                _provider = StreamProvider(model.pluginObject);            }        }    }}}